#### ```Implicitly Unwrapped Optional```를 사용하는 이유
1. 애플이 권장하는 방식입니다. (자동완성)
2. Swift 언어 특성상, ```struct```나 ```class```가 인스턴스로 생성될 때 저장 프로퍼티에 초기값을 저장해야 합니다. 그렇기 때문에 Viewcontroller가 인스턴스화될 때 IBOutlet의 값은 항상 존재해야 합니다. 고로 강제 언래핑을 사용을 추

#### 참고 
- [Optional IBOutlet Blog1](https://blog.curtisherbert.com/to-optional-or-not-to-optional-iboutlet/)
- [Optional IBOutlet Blog2](https://cocoacasts.com/should-outlets-be-optionals-or-implicitly-unwrapped-optionals)



## Copy On Write





메모리 관리 (ARC: Automatic Reference Counting)

- ARC는 메모리 영역 중 힙 영역을 관리한다.

- ARC는 앱의 메모리를 추적하고 관리하는 역할을 한다.

- 인스턴스가 더 이상 필요하지 않을 경우 메모리 해제를 해야 한다. 그 이유는 클래스가 더 이상 필요 없을 때 불필요하게 메모리를 차지하는 것을 방지하기 위함이다.
- ARC는 현재 각 클래스 인스턴스를 참조하는 속성, 상수 및 변수의 수를 추적한다.
- 모든 인스턴스는 RC를 가지고 있다.



ARC 

메모리의 참조 횟수(RC: Reference Count)를 계산하여, 참조 횟수가 0이 되면 더 이상 사용하지 않는 메모리라 생각하여 해제한다.



예시 

```swift 
class Person {
  var name: String
  var age: Int
  init(name: String, age: Int) {
    self.name = name
    self.age = age
    
  }
}

let song = Person() // song이라는 인스턴스의 RC가 +1됨
let duplication = song // song 인스턴스의 RC가 +1됨
```





참조 횟수 Count Up(+)



1. 인스턴스를 새로 생성할 경우 

```swift
let song = Person(name: "Song", age: 26) // song이라는 인스턴스에 RC +1됨
```



2. 기존 인스턴스를 다른 변수에 대입할 경우

```swift
let duplication = song // song이라는 인스턴스에 RC +1됨
```



참조 횟수 Count Down

1. 인스턴스를 가리키던 변수가 메모리에서 해제되었을 때

- 예시에서 ``duplication``함수에 있는 duplication에서 ``song``의 RC가 +1되고, 함수 호출 종료 시 RC가 -1된다.

```swift
func duplicate() {
  let duplication = song
}
let song = Person(name: "Song", age: 26) // song의 RC = 1

duplication() // 호출 시 song의 RC = 2
							// 함수가 종료되면서 RC = 1

```



2. nil이 지정되었을 때

1. 변수에 다른 값을 대입한 경우
2. 프로퍼티의 경우, 속해 있는 클래스 인스턴스가 메모리에서 해제될 때