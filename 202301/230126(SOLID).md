SOLID

객체지향 설계에 더 좋은 아키텍쳐를 설계하기 위해 지켜야하는 원칙들의 5가지를 앞의 약어만 따서 정리한 단어이다.



SRP(Single Responsibility Principle) - 단일 책임 원칙

클래스나 함수를 설계할 때, 각 단위들은 단 하나의 책임만을 가져야한다는 원칙

소프트웨어 요소(클래스, 모듈, 함수 등)는 응집도 있는 하나의 책임을 갖는다. 클래스를 변경해야 하는 이유는 단지 응집도여야 한다.





OCP(Open-Closed Principle) - 개방, 폐쇄 원칙

확장에는 열려있으나 변경에는 닫혀있어야 한다는 원칙

소프트웨어 요소는 확장 가능하도록 열려있고, 변경에는 닫혀있어야 한다. 새 기능을 추가할 때 변경하지 말고 새 클래스나 함수를 만들어라



LSP(Liskov Substitution Principle) - 리스코프 치환 원칙

Super class로 동작하는 곳에서 Sub class를 넣어주어도 대체가 가능해야 한다는 원칙 

서브타입은 (상속받은) 기본 타입으로 대체가능해야 한다. 자식 클래스는 부모 클래스 동작(의미)를 바꾸지 않는다.

자식 클래스는 부모 클래스의 동작을 바꾸면 안된다. 



DIP(Dependecy Inversion Principle) - 의존관계 역전 원칙 

상위 모듈이 하위 모듈에 의존하면 안되고 두 모듈 모두 추상화에 의존하게 만들어야 한다는 원칙 

상위레벨 묘듈은 하위레벨 모듈에 의존하면 안된다. 둘 다 추상화되 인터페이스에 의존해야 한다. 추상화는 구체화에 의존하면 안되고, 구체화는 추상화에 의존하면 안된다. 



ISP(Interface Segregation Principle) - 인터페이스 분리 원칙 

인터페이스를 일반화하여 구현하지 않는 인터페이스를 채택하는 것보다 구체적인 인터페이스를 채택하는 것이 더 좋다는 원칙

클라이언트 객체는 사용하지 않는 메소드에 의존하면 안된다.



왜지켜야 하나!

유지보수, 확장이 쉬운 코드를 만들수 있다?

다른 개발자가 이해하기 쉽다



가치와 원칙 

가치 : 가치는 원칙보다 높은 수준의 개념

원칙 : 원칙은 가치를 지키기 위해서 존재 





소프트웨어의 가치

1. 가독성, 커뮤니케이션

- 개발자는 코드를 통해 의사소통을 한다.
- 읽고 이해할 수 없는 코드는 더욱 가치가 없다.

2. 단순성

- 코드는 단순해야 한다.
- 커뮤니케이션에 도움이 된다.
- 버그가 생길 틈이 없어진다.
- 미래의 확장을 위한 복잡한 패턴은 경계의 대상

3. 유연성

- 기존의 코드를 수정하는 데에 최대한 적은 시간을 사용해야 한다.
- 처음부터 유연성있는 코드를 작성하는데에는 많은 경험이 필요하다.



유연성은 언제 챙겨?

1. 처음엔 단순하게

2. 기획 또는 정책의 변경이 발생

3. 이 기획 또는 정책의 변경의 원인은 무엇일까?

이러한 변경이 계속 발생 가능한 일일까?

4. 확장성을 고려한 리팩토링을 해보자



OOP (Object Oriented Programming)

객체 지향 프로그래밍



접근제어 

접근제어는 코드, 파일, 모듈 간의 접근을 제한해주는 것이다. 이것은 구체적인 코드를 외부로 부터 숨기고, 보호할 수 있다.

- Open Access / Public Access
  - 어떤 소스파일에서든 사용할 수 있는 접근제어자이다.
  - 일반적으로 프레임워크에 대한 공용 인터페이스를 지정할 때 사용된다. 
- Internal Access
  - 모듈이 정의된 소스 파일 내에서 사용이 가능하며, 모든 소스파일에서 공유할 수 없다.
  - 일반적으로 앱 또는 프레임워크의 내부 구조를 정의할 때 사용된다.
  - default가 lnternal Access이다.
- File Private Access
  - 동일한 소스 파일 내에서 접근이 가능하다. 즉, 해당 클래스가 정의된 소스 코드에서는 fileprivate로 선언된 프로퍼티에 접근할 수 있다.
- Private Access
  - 동일 클래스 내에서만 접근이 가능하다.
  - extension을 통해서도 접근이 가능하다.



private(set) 이란 private를 사용하여, 외부에서 읽을 수 있지만, 수정할 수 없게 만드는 접근제어자입니다.

그렇다면 "`peek`과 `isEmpty`는 `private`을 사용할 필요가 없을까?" 라는 의문점이 들었습니다.

`peek`과 `isEmpty`는 읽기 전용 프로퍼티로 외부에서는 수정이 불가하여, private을 붙여줄 필요가 없습니다.



@discardableResult

삭제 가능한 결과 

선언할 경우 반환값을 쓰든 안쓰든 신경 안 써도 된다.

"Result of call to ' ~~~~' is unused"





`setUpWithError`와 `tearDownWithError`메서드는 언제 호출

이외에도 비슷한 기능을 하는 메서드



CaseIterable

열거형에 있는 case들을 순회할 수 있게 해주는 프로토콜이다. 

```Swift
import UIKit

enum abc: Character, CaseIterable {
    case car = "a"
    case bee = "b"
    case apple = "c"
}

var list = [String]()

for a in abc.allCases {
    print(a.rawValue)
}

for b in abc.allCases {
    print(b)
}


```

